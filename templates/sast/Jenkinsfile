def containerListYaml() {
  def containerListYaml = reindent(10, """
    - name: fetch
      image: artifactory.cloud.cms.gov/docker/alpine:3
      command: ['tail', '-f', '/dev/null']
    - name: sonarqube
      image: artifactory.cloud.cms.gov/docker/sonarsource/sonar-scanner-cli:5
      command: ['tail', '-f', '/dev/null']""");

  return containerListYaml
}

def reindent(spaces, str) {
  def lines = str.split('\n')
  // Ignoring blank lines, determine the minimum number of leading spaces
  def indents = lines.findAll { it.trim() }.collect { (it =~ /^( *)/)[0][0].size() }
  def minIndent = indents[0]
  for (indent in indents) {
    if (indent < minIndent) {
      minIndent = indent
    }
  }

  return str.split('\n').collect { it ? " " * spaces + it.substring(minIndent) : it }.join('\n')
}

pipeline {
  parameters {
    string(name: 'git_repository', description: 'The URL of the Git repository to clone when building the container image.')
    string(name: 'git_commit', description: 'The commit hash or branch name to checkout when building the container image.')
    string(name: 'git_credentials', description: 'The ID of the Jenkins credentials to use when cloning the Git repository.')
    string(name: 'git_branch', defaultValue: "", description: 'The branch that the current build is for (used when reporting results for SonarQube to identify new code and associate detected issues with the branch).')
    string(name: 'git_change_id', defaultValue: "", description: '(Optional) A unique identifier for a pull request (used by SonarQube to track issues detected in new code).')
    string(name: 'sonarqube_url', defaultValue: "${default_sonarqube_url ?: ''}", description: 'The URL of the SonarQube server.')
    string(name: 'sonarqube_project_key', defaultValue: "${default_sonarqube_project_key ?: ''}", description: 'The SonarQube project key to use when reporting issues.')
    string(name: 'sonarqube_additional_arguments', defaultValue: "${default_sonarqube_additional_arguments ?: ''}", description: 'A JSON serialized array of additional arguments to pass to the SonarQube scanner.')
    string(name: 'source_path', defaultValue: "${default_source_path ?: '.'}", description: 'The relative path of the source code to scan.')
    string(name: 'copy_artifacts_job_name', defaultValue: '', description: 'Optional, name of the Jenkins job from which to copy build artifacts that may be required by the Dockerfile.')
    string(name: 'copy_artifacts_build_number', defaultValue: '', description: 'Optional, specific build number of artifacts to copy.')
    string(name: 'copy_artifacts_filter', defaultValue: '', description: 'Optional, filemask to identify build artifacts to copy.')
  }

  agent {
    kubernetes {
      yaml """
      apiVersion: v1
      kind: Pod
      spec:
        restartPolicy: Never
        containers:${containerListYaml()}"""
    }
  }

  stages {
    stage("Fetch") {
      steps {
        container('fetch') {
          checkout scmGit(
            branches: [[ name: "${params.git_commit}" ]],
            userRemoteConfigs: [[
              url: "${params.git_repository}",
              credentialsId: "${params.git_credentials}",
              refspec: "+${params.git_commit}:refs/remotes/origin/HEAD"
            ]],
            extensions: [
              cloneOption(shallow: true, honorRefspec: true, noTags: true),
              submodule(recursiveSubmodules: true, shallow: true)
            ]
          )
        }
      }
    }
    stage("Scan Source") {
      steps {
        container('sonarqube') {
          withCredentials([string(credentialsId: "${sonarqube_token}", variable: 'SONAR_TOKEN')]) {
            script {
              def project_settings_url = "${params.sonarqube_url}/api/settings/values?component=${params.sonarqube_project_key}"
              def projectSettingsJson = sh(
                script: """
                  curl --location '${project_settings_url}&keys=sonar.projectCreation.mainBranchName' \
                    --header "Authorization: Basic \$(echo -n \${SONAR_TOKEN}: | base64)" \
                    --no-progress-meter -f
                """,
                returnStdout: true
              )
              echo "Fetched SonarQube project settings: ${projectSettingsJson}"
              def defaultBranch =
                new groovy.json.JsonSlurper().parseText(projectSettingsJson).settings.find { it.key == 'sonar.projectCreation.mainBranchName' }?.value ?: 'main'
              def args = [
                '-Dsonar.login=$SONAR_TOKEN',
                "-Dsonar.host.url=${params.sonarqube_url}",
                "-Dsonar.projectKey=${params.sonarqube_project_key}",
                "-Dsonar.sources=${params.source_path}",
                "-Dsonar.qualitygate.wait=true"
              ]
              if (params.git_branch == defaultBranch) {
                echo "Performing analysis for the default branch: ${defaultBranch}"
                args.add("-Dsonar.branch.name=${params.git_branch}")
              } else {
                echo "Performing analysis for a feature branch: ${params.git_branch} (does not match default branch ${defaultBranch})"
                args.add("-Dsonar.pullrequest.branch=${params.git_branch ?: params.git_commit}")
                args.add("-Dsonar.pullrequest.key=${params.git_change_id ?: (params.git_branch ?: params.git_commit)}")
              }

              if (params.copy_artifacts_job_name && params.copy_artifacts_build_number && params.copy_artifacts_filter) {
                copyArtifacts projectName: params.copy_artifacts_job_name, filter: params.copy_artifacts_filter, selector: specific(params.copy_artifacts_build_number)
              }
              if (params.sonarqube_additional_arguments) {
                def argArray = new groovy.json.JsonSlurper().parseText(params.sonarqube_additional_arguments)
                // Add all the items in argArray to the args list
                args.addAll(argArray)
              }
              sh "sonar-scanner ${args.join(' ')}"
            }
          }
        }
      }
    }
  }
}
