pipeline {
  parameters {
    string(name: 'git_repository', description: 'The URL of the Git repository to clone when building the container image.')
    string(name: 'git_commit', description: 'The commit hash or branch name to checkout when building the container image.')
    string(name: 'git_credentials', description: 'The ID of the Jenkins credentials to use when cloning the Git repository.')
    booleanParam(name: 'image_push_enabled', defaultValue: "${default_image_push_enabled ?: false}", description: 'Enable the image push step.')
    string(name: 'image', defaultValue: "${default_image ?: 'my-app'}", description: 'The fully qualified container image name.')
    string(name: 'tag', defaultValue: "${default_tag ?: 'latest'}", description: 'Container image tag.')

    booleanParam(name: 'update_latest', defaultValue: "${default_update_latest ?: false}", description: 'When true, update the latest tag to point to the newly built image.')
    string(name: 'build_args', defaultValue: "${default_build_args ?: '{}'}", description: 'A JSON object of build arguments to pass to the container build process.')
    string(name: 'build_dir', defaultValue: "${default_build_dir ?: '.'}", description: 'The directory to use as the build context for the container build.')
    string(name: 'dockerfile', defaultValue: "${default_dockerfile ?: 'Dockerfile'}", description: 'The path to the Dockerfile to use for the container build.')
    string(name: 'build_target', defaultValue: "${default_build_target ?: ''}", description: 'The build target to use when building the container image (for use with multi-stage Dockerfiles).')
    string(name: 'copy_artifacts_job_name', defaultValue: '', description: 'Optional, name of the Jenkins job from which to copy build artifacts that may be required by the Dockerfile.')
    string(name: 'copy_artifacts_build_number', defaultValue: '', description: 'Optional, specific build number of artifacts to copy.')
    string(name: 'copy_artifacts_filter', defaultValue: '', description: 'Optional, filemask to identify build artifacts to copy.')
    string(name: 'platform', defaultValue: "${default_platform ?: ''}", description: 'A comma separated list of platforms to build the container image for (e.g., linux/amd64,linux/arm64).')
    choice(name: 'log_level', choices: ['info', 'panic', 'fatal', 'error', 'warn', 'debug', 'trace'], description: 'The log level to use for the container build process.')
    string(name: 'kaniko_memory_limit', defaultValue: "${default_kaniko_memory_limit ?: '1Gi'}", description: "Kaniko memory limit input for those larger builds.")

    booleanParam(name: 'enable_cache', defaultValue: "${default_enable_cache ?: false}", description: 'Enable Kaniko image build cache.')
  }

  agent {
    kubernetes {
      yaml """
      apiVersion: v1
      kind: Pod
      metadata:
        annotations:
          com.cloudbees.sidecar-injector/inject: no
      spec:
        restartPolicy: Never
        containers:
        - name: fetch
          image: artifactory.cloud.cms.gov/docker/alpine:3
          command: ['tail', '-f', '/dev/null']
        - name: kaniko
          image: artifactory.cloud.cms.gov/docker/kaniko-project/executor:v1.23.1-debug
          command: ['tail', '-f', '/dev/null']
          resources:
            limits:
              memory: "${params.kaniko_memory_limit}"    
        - name: clamav
          image: artifactory.cloud.cms.gov/docker/clamav/clamav:latest
          command: ['tail', '-f', '/dev/null']
          resources:
            limits:
              memory: "5Gi"
            requests:
              memory: "3Gi"
        - name: crane
          image: gcr.io/go-containerregistry/crane/debug:latest
          command: ['tail', '-f', '/dev/null']
      """
    }
  }

  stages {
    stage('Build Image') {
      steps {
        container('fetch') {
          checkout scmGit(
            branches: [[ name: "${params.git_commit}" ]],
            userRemoteConfigs: [[
              url: "${params.git_repository}",
              credentialsId: "${params.git_credentials}",
              refspec: "+${params.git_commit}:refs/remotes/origin/HEAD"
            ]],
            extensions: [
              cloneOption(shallow: true, honorRefspec: true, noTags: true),
              submodule(recursiveSubmodules: true, shallow: true)
            ]
          )
        }
        container('kaniko') {
          script {
            def arguments = [
              "--context=${params.build_dir}",
              "--dockerfile=${params.dockerfile}",
              "--destination=${params.image}:${params.tag}",
              "--verbosity=${params.log_level}",
              '--no-push',
              '--tar-path=./image.tar'
            ]

            if (params.build_target) {
              echo "build_target (${params.build_target.getClass()}): ${params.build_target}"
              echo "default_build_target: ${default_build_target}"
              arguments.add("--target=${params.build_target}")
            }

            if (params.platform) {
              arguments.add("--custom-platform=${params.platform}")
            }

            if (params.build_args) {
              def argMap = new groovy.json.JsonSlurper().parseText(params.build_args)
              argMap.each { key, value ->
                arguments.add("--build-arg=${key}='${value}'")
              }
            }

            if (params.copy_artifacts_job_name && params.copy_artifacts_build_number && params.copy_artifacts_filter) {
              copyArtifacts projectName: params.copy_artifacts_job_name, filter: params.copy_artifacts_filter, selector: specific(params.copy_artifacts_build_number)
            }

            if (params.enable_cache) {
              arguments.add("--cache=${params.enable_cache}")
              arguments.add("--cache-repo=${params.image}-cache")
              arguments.add("--compressed-caching=false")
              arguments.add("--cache-dir=/kaniko/cache")
              arguments.add("--cache-run-layers")
              arguments.add("--cache-copy-layers")
            }

            // Authentication by copying a docker config JSON to config directory
            withCredentials([file(credentialsId: "${image_registry_auth_json}", variable: 'AUTH_JSON_FILE')]) {
              echo 'export image registry auth json to /kaniko/.docker/config.json'
              sh 'mkdir -p /kaniko/.docker'
              sh 'mv "$AUTH_JSON_FILE" /kaniko/.docker/config.json'

              if ("${enable_ansi_colors}" == "true") {
                ansiColor('xterm') {
                  sh "/kaniko/executor ${arguments.join(' ')}"
                }
              } else {
                sh "/kaniko/executor ${arguments.join(' ')}"
              }
            }
          }
        }
      }
    }

    stage('Malware Scan') {
      steps {
        container('clamav') {
          script {
            sh "freshclam"
            sh "touch virus-report.clamav.txt"
            sh "pwd && ls -laH"
            sh "clamscan --infected --recursive --scan-archive=yes --max-filesize=500M --max-scansize=500M --stdout ./image.tar"
          }
        }
      }
    }

    stage('Image Publish') {
      steps {
        container('crane') {
          script {
            if (!params.image_push_enabled) {
              echo 'image_push_enabled is set to false, skipping the image push step'
              return
            }

            // Authentication by copying a docker config JSON to config directory
            withCredentials([file(credentialsId: "${image_registry_auth_json}", variable: 'AUTH_JSON_FILE')]) {
              echo 'export image registry auth json to /root/.docker/config.json'
              sh 'mkdir -p /root/.docker'
              sh 'mv "$AUTH_JSON_FILE" /root/.docker/config.json'
              sh 'crane version'
              sh 'pwd && ls -laH'
              sh "crane push ./image.tar ${params.image}:${params.tag}"

              if (params.update_latest) {
                sh "crane push ./image.tar ${params.image}:latest"
              }
            }
          }
        }
      }
    }
  }
}
