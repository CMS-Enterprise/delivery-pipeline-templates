pipeline {
  parameters {
    string(name: 'git_repository', description: 'The URL of the Git repository to clone when building the container image.')
    string(name: 'git_commit', description: 'The commit hash or branch name to checkout when building the container image.')
    string(name: 'git_credentials', description: 'The ID of the Jenkins credentials to use when cloning the Git repository.')
    string(name: 'image_registry', description: 'the image registry URL for authentication')
    string(name: 'image_registry_user', description: 'the image registry username for authentication')
    string(name: 'image_registry_token', description: 'the image registry token for authentication')
    boolParam(name: 'image_push_enabled', defaultValue: false, description: 'optionally enable/disable the image push step.')
    string(name: 'image', defaultValue: "${default_image ?: 'my-app'}", description: 'The fully qualified container image name.')
    string(name: 'tag', defaultValue: "${default_tag ?: 'latest'}", description: 'Container image tag.')

    booleanParam(name: 'update_latest', defaultValue: false, description: 'When true, update the latest tag to point to the newly built image.')
    string(name: 'build_args', defaultValue: "${default_build_args ?: '{}'}", description: 'A JSON object of build arguments to pass to the container build process.')
    string(name: 'build_dir', defaultValue: "${default_build_dir ?: '.'}", description: 'The directory to use as the build context for the container build.')
    string(name: 'dockerfile', defaultValue: "${default_dockerfile ?: 'Dockerfile'}", description: 'The path to the Dockerfile to use for the container build.')
    string(name: 'build_target', defaultValue: "${default_build_target ?: ''}", description: 'The build target to use when building the container image (for use with multi-stage Dockerfiles).')
    string(name: 'copy_artifacts', defaultValue: '', description: 'Optional, name of the Jenkins job from which to copy build artifacts that may be required by the Dockerfile.')
    string(name: 'platform', defaultValue: "${default_platform ?: ''}", description: 'A comma separated list of platforms to build the container image for (e.g., linux/amd64,linux/arm64).')
    choice(name: 'log_level', choices: ['info', 'panic', 'fatal', 'error', 'warn', 'debug', 'trace'], description: 'The log level to use for the container build process.')
    string(name: 'kaniko_memory_limit', defaultValue: "${default_kaniko_memory_limit ?: '1Gi'}", description: 'Kaniko memory limit input for those larger builds.')

    boolParam(name: 'clamscan_enabled', defaultValue: true, description: 'optionally enable/disable the clamscan antivirus scan.')
  }

  agent {
    kubernetes {
      yaml """
      apiVersion: v1
      kind: Pod
      metadata:
        annotations:
          com.cloudbees.sidecar-injector/inject: no
      spec:
        restartPolicy: Never
        containers:
        - name: fetch
          image: artifactory.cloud.cms.gov/docker/alpine:3
          command: ['tail', '-f', '/dev/null']
        - name: kaniko
          image: artifactory.cloud.cms.gov/docker/kaniko-project/executor:v1.23.1-debug
          command: ['tail', '-f', '/dev/null']
          resources:
            limits:
              memory: "${params.kaniko_memory_limit}"
        - name: clamav
          image: artifactory.cloud.cms.gov/docker/clamav/clamav:latest
          command: ['tail', '-f', '/dev/null']
          resources:
            limits:
              memory: "5Gi"
            requests:
              memory: "3Gi"
        - name: crane
          image: gcr.io/go-containerregistry/crane:latest
          command: ['tail', '-f', '/dev/null']
      """
    }
  }

  stages {
    stage('Build Image') {
      steps {
        container('fetch') {
          checkout scmGit(
            branches: [[ name: "${params.git_commit}" ]],
            userRemoteConfigs: [[
              url: "${params.git_repository}",
              credentialsId: "${params.git_credentials}",
              refspec: "+${params.git_commit}:refs/remotes/origin/HEAD"
            ]],
            extensions: [
              cloneOption(shallow: true, honorRefspec: true, noTags: true),
              submodule(recursiveSubmodules: true, shallow: true)
            ]
          )
        }
        container('kaniko') {
          script {
            def arguments = [
              "--context=${params.build_dir}",
              "--dockerfile=${params.dockerfile}",
              "--destination=${params.image}:${params.tag}",
              "--verbosity=${params.log_level}",
              "--cache=${enable_cache}",
              "--cache-repo=${params.image}",
              '--no-push',
              '--no-push-cache',
              '--tar-path=./image.tar'
            ]

            if (params.build_target) {
              echo "build_target (${params.build_target.getClass()}): ${params.build_target}"
              echo "default_build_target: ${default_build_target}"
              arguments.add("--target=${params.build_target}")
            }

            if (params.platform) {
              arguments.add("--custom-platform=${params.platform}")
            }

            if (params.build_args) {
              def argMap = new groovy.json.JsonSlurper().parseText(params.build_args)
              argMap.each { key, value ->
                arguments.add("--build-arg=${key}='${value}'")
              }
            }

            if (params.copy_artifacts) {
              copyArtifacts projectName: params.copy_artifacts, filter: '**/target/*.jar', selector: upstream()
            }

            if ("${enable_ansi_colors}" == 'true') {
              ansiColor('xterm') {
                sh "/kaniko/executor ${arguments.join(' ')}"
              }
            } else {
              sh "/kaniko/executor ${arguments.join(' ')}"
            }
          }
        }

        container('clamav') {
          script {
            if (!params.clamscan_enabled) {
              echo 'clamscan_enabled is set to false, skipping the image antivirus scan with ClamAV step'
              return
            }
            sh 'freshclam'
            sh 'touch virus-report.clamav.txt'
            sh 'pwd && ls -laH'
            sh 'clamscan --infected --recursive --scan-archive=yes --max-filesize=500M --max-scansize=500M --stdout ./image.tar'
          }
        }

        container('crane') {
          script {
            if (!params.image_push_enabled) {
              echo 'image_push_enabled is set to false, skipping the image push step'
              return
            }
            sh 'crane --version'
            sh 'pwd && ls -laH'
            sh "crane push ./image.tar ${params.image}:${params.tag}"
          }
        }
      }
    }
  }
}
